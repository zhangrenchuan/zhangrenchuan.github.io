{"meta":{"title":"Incheon's Life","subtitle":null,"description":null,"author":"Incheon","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"基础面试笔记","slug":"基础面试笔记","date":"2019-08-26T09:37:36.000Z","updated":"2019-08-26T09:47:04.427Z","comments":true,"path":"2019/08/26/基础面试笔记/","link":"","permalink":"http://yoursite.com/2019/08/26/基础面试笔记/","excerpt":"数据类型Undefined，Null，Number，String，Boolean。引用类型，Object。ES6新增了数据类型Symbol，表示独一无二的值。 事件流 事件流被分为三个阶段(1~ 5)捕获过程、(5~ 6)事件触发过程、(6~ 10)冒泡过程 移动端的触摸事件 touchstart 当手指触摸屏幕时触发 touchmove 当手指在屏幕上滑动时连续触发 touchend 当手指离开屏幕时触发 touchcancel 系统停止跟踪触摸时触发","text":"数据类型Undefined，Null，Number，String，Boolean。引用类型，Object。ES6新增了数据类型Symbol，表示独一无二的值。 事件流 事件流被分为三个阶段(1~ 5)捕获过程、(5~ 6)事件触发过程、(6~ 10)冒泡过程 移动端的触摸事件 touchstart 当手指触摸屏幕时触发 touchmove 当手指在屏幕上滑动时连续触发 touchend 当手指离开屏幕时触发 touchcancel 系统停止跟踪触摸时触发 触摸事件还提供以下属性 touches 跟踪返回Touch对象的数组 targetTouchs 特定事件目标的Touch对象的数组 changeTouchs 上次触摸以来改变了的Touch对象的数组 每个Touch对象包含以下属性 clientX: 触摸目标在浏览器中的x坐标 clientY: 触摸目标在浏览器中的y坐标 identifier: 标识触摸的唯一ID。 pageX: 触摸目标在当前DOM中的x坐标 pageY: 触摸目标在当前DOM中的y坐标 screenX: 触摸目标在屏幕中的x坐标 screenY: 触摸目标在屏幕中的y坐标 target: 触摸的DOM节点目标。 页面加载过程/就是输入url到加载出页面 输入地址 浏览器查找域名的 IP 地址 这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存… 浏览器向 web 服务器发送一个 HTTP 请求 服务器的永久重定向响应（从 http://example.com 到 http://www.example.com） 浏览器跟踪重定向地址 服务器处理请求 服务器返回一个 HTTP 响应 浏览器显示 HTML 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等） 浏览器发送异步请求 路由器缓存通俗点说，每个路由器根据所在网络的不同，都有自己的路由表，在工作时会选择相应的路径。为什么要有路由器缓存呢，这个也是为了发送数据，因为路由器最高层一般都是网络层，网络层一般都是传送数据包，数据包又是经过应用层向下传送之后送来的一部分文件数据，如果我们没有缓存的话，那么，每次都会查找传送到达方的ip地址就会很费力。 跨域 跨域就是它是由浏览器的同源策略造成的，是浏览器施加的安全限制 所谓同源是指，域名，协议，端口均相同 例: 123456789http://www.123.com/index.html 调用 http://www.123.com/server.php （非跨域）http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域） 为什么要实现跨域？防止CSRF攻击 解决跨域 jsonp 源代码 cors 跨域资源共享CORS详解 作用域闭包 有权访问另一个函数作用域的函数 前端缓存 Cookie 存储容量小,不安全 LocalStorge 持久化存储 SessionStorge 关闭浏览器清空","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"面试系列","slug":"面试系列","permalink":"http://yoursite.com/tags/面试系列/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"CSS简单性能优化","slug":"CSS简单性能优化","date":"2019-08-26T09:05:44.000Z","updated":"2019-08-26T09:46:34.389Z","comments":true,"path":"2019/08/26/CSS简单性能优化/","link":"","permalink":"http://yoursite.com/2019/08/26/CSS简单性能优化/","excerpt":"慎重选择高性能样式 合理安排Selectore 高消耗属性要注意: box-shadows边框阴影; border-radius盒子圆角; transparency透明度; transforms变形; CSS filters 滤镜（性能杀手）","text":"慎重选择高性能样式 合理安排Selectore 高消耗属性要注意: box-shadows边框阴影; border-radius盒子圆角; transparency透明度; transforms变形; CSS filters 滤镜（性能杀手） 避免过分的重排 (Reflow) 浏览器会重新计算布局位置与大小 常见重排元素: width, height, left, top, right, bottom, padding, margin, display, border, position, font-size, float, text-align, overflow, clear, white-space, min-height 避免过分重绘 (Repaints) 常见重绘元素: color, border-style, visibility, background, outline, borde-radius, box-shadow 衡量属性和布局消耗代价 探索W3C的性能优化新规范 用测试数据判断优化策略 多利用GPU性能","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}]}